## event trigger 

`event trigger` 生成代码为开发者提供触发捕获事件的逻辑实现。
主要生成类似与以下代码：

```go
    func OnEvXXX(func(*Object, EvXXX)) {}
    func TriggerEvXXX(EvXXX) {}

    func CheckEvXXX(func(*Object, EvXXX)) {}
```

其中 `On`, `Trigger` 提供捕获事件与触发事件的能力，而`Check` 针对开发者使用自定义逻辑来
避免捕获的能力(该功能是可选项)。

例子：

```go
package pick

import "time"

//go:generate event_trigger -obj=Po -prefix=Ev type.go

type (
	Po struct {
		Name string
		Age  int32
	}
	EvPick struct {
		Name string
		When time.Time
	}
	// EvDrop need_check
	EvDrop struct{}
)
```

使用 `go generate` 后，会在本地生成一份代码:

```go
// Code generated by "trigger -obj=Po -prefix=Ev type.go"; DO NOT EDIT.

package pick

type EventHandler struct {
	dropCheck func(obj *Po, drop EvDrop) bool

	pickWatcher []func(obj *Po, pick EvPick)
	dropWatcher []func(obj *Po, drop EvDrop)
}

type EventTable struct {
	o *Po
	h *EventHandler
}

func (t *EventHandler) CreateObject(o *Po) *EventTable {
	return &EventTable{
		o: o,
		h: t,
	}
}

func (t *EventHandler) OnEvPick(f func(*Po, EvPick)) {
	t.pickWatcher = append(t.pickWatcher, f)
}

func (t *EventTable) TriggerEvPick(e EvPick) {
	for _, f := range t.h.pickWatcher {
		f(t.o, e)
	}
}

func (t *EventHandler) CheckEvDrop(f func(*Po, EvDrop) bool) {
	t.dropCheck = f
}

func (t *EventHandler) OnEvDrop(f func(*Po, EvDrop)) {
	t.dropWatcher = append(t.dropWatcher, f)
}

func (t *EventTable) TriggerEvDrop(e EvDrop) {
	if t.h.dropCheck != nil && !t.h.dropCheck(t.o, e) {
		return
	}
	for _, f := range t.h.dropWatcher {
		f(t.o, e)
	}
}
```

之后，开发者就可以使用以下代码：

```go
h := new(EventHandler)
h.OnEvPick(func(po *Po, Pick EvPick) {
fmt.Printf("%s is Picking %s at %s\n", po.Name, Pick.Name, Pick.When)
})
po := &Po{
Name: "john", Age: 13,
}
table := h.CreateObject(po)

ev := EvPick{
Name: "apple",
When: time.Now(),
}
table.TriggerEvPick(ev)
```